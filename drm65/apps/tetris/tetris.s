;
; File generated by cc65 v 2.13.3
;
	.fopt		compiler,"cc65 v 2.13.3"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank, tmp1, ptr1, ptr2
	.macpack	longbranch
	.forceimport	__STARTUP__
	.export		_campo
	.export		_oldc
	.export		_pieza
	.export		_piezas
	.export		_ptab
	.export		_init_pt
	.export		_xp
	.export		_yp
	.export		_rand
	.export		_txtx
	.export		_txty
	.export		_cout
	.import		_cinnb
	.import		_cls
	.export		_puts
	.export		_delay16m
	.export		_posx
	.export		_posy
	.export		_prtnum
	.export		_cuad
	.export		_cuadro
	.export		_testpos
	.export		_rota
	.export		_init
	.export		_display
	.export		_main

.segment	"RODATA"

_ptab:
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$03
	.byte	$03
	.byte	$03
	.byte	$00
	.byte	$03
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$04
	.byte	$04
	.byte	$00
	.byte	$04
	.byte	$04
	.byte	$00
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$05
	.byte	$05
	.byte	$00
	.byte	$00
	.byte	$06
	.byte	$06
	.byte	$06
	.byte	$00
	.byte	$00
	.byte	$06
	.byte	$00
	.byte	$00
	.byte	$07
	.byte	$07
	.byte	$00
	.byte	$00
	.byte	$07
	.byte	$07
	.byte	$00
_cuad:
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$99
	.byte	$99
	.byte	$99
	.byte	$98
	.byte	$91
	.byte	$11
	.byte	$11
	.byte	$18
	.byte	$91
	.byte	$88
	.byte	$88
	.byte	$18
	.byte	$91
	.byte	$81
	.byte	$19
	.byte	$18
	.byte	$91
	.byte	$81
	.byte	$19
	.byte	$18
	.byte	$91
	.byte	$89
	.byte	$99
	.byte	$18
	.byte	$91
	.byte	$11
	.byte	$11
	.byte	$18
	.byte	$98
	.byte	$88
	.byte	$88
	.byte	$88
	.byte	$AA
	.byte	$AA
	.byte	$AA
	.byte	$A8
	.byte	$A2
	.byte	$22
	.byte	$22
	.byte	$28
	.byte	$A2
	.byte	$88
	.byte	$88
	.byte	$28
	.byte	$A2
	.byte	$82
	.byte	$2A
	.byte	$28
	.byte	$A2
	.byte	$82
	.byte	$2A
	.byte	$28
	.byte	$A2
	.byte	$8A
	.byte	$AA
	.byte	$28
	.byte	$A2
	.byte	$22
	.byte	$22
	.byte	$28
	.byte	$A8
	.byte	$88
	.byte	$88
	.byte	$88
	.byte	$BB
	.byte	$BB
	.byte	$BB
	.byte	$B8
	.byte	$B3
	.byte	$33
	.byte	$33
	.byte	$38
	.byte	$B3
	.byte	$88
	.byte	$88
	.byte	$38
	.byte	$B3
	.byte	$83
	.byte	$3B
	.byte	$38
	.byte	$B3
	.byte	$83
	.byte	$3B
	.byte	$38
	.byte	$B3
	.byte	$8B
	.byte	$BB
	.byte	$38
	.byte	$B3
	.byte	$33
	.byte	$33
	.byte	$38
	.byte	$B8
	.byte	$88
	.byte	$88
	.byte	$88
	.byte	$CC
	.byte	$CC
	.byte	$CC
	.byte	$C8
	.byte	$C4
	.byte	$44
	.byte	$44
	.byte	$48
	.byte	$C4
	.byte	$88
	.byte	$88
	.byte	$48
	.byte	$C4
	.byte	$84
	.byte	$4C
	.byte	$48
	.byte	$C4
	.byte	$84
	.byte	$4C
	.byte	$48
	.byte	$C4
	.byte	$8C
	.byte	$CC
	.byte	$48
	.byte	$C4
	.byte	$44
	.byte	$44
	.byte	$48
	.byte	$C8
	.byte	$88
	.byte	$88
	.byte	$88
	.byte	$DD
	.byte	$DD
	.byte	$DD
	.byte	$D8
	.byte	$D5
	.byte	$55
	.byte	$55
	.byte	$58
	.byte	$D5
	.byte	$88
	.byte	$88
	.byte	$58
	.byte	$D5
	.byte	$85
	.byte	$5D
	.byte	$58
	.byte	$D5
	.byte	$85
	.byte	$5D
	.byte	$58
	.byte	$D5
	.byte	$8D
	.byte	$DD
	.byte	$58
	.byte	$D5
	.byte	$55
	.byte	$55
	.byte	$58
	.byte	$D8
	.byte	$88
	.byte	$88
	.byte	$88
	.byte	$EE
	.byte	$EE
	.byte	$EE
	.byte	$E8
	.byte	$E6
	.byte	$66
	.byte	$66
	.byte	$68
	.byte	$E6
	.byte	$88
	.byte	$88
	.byte	$68
	.byte	$E6
	.byte	$86
	.byte	$6E
	.byte	$68
	.byte	$E6
	.byte	$86
	.byte	$6E
	.byte	$68
	.byte	$E6
	.byte	$8E
	.byte	$EE
	.byte	$68
	.byte	$E6
	.byte	$66
	.byte	$66
	.byte	$68
	.byte	$E8
	.byte	$88
	.byte	$88
	.byte	$88
	.byte	$FF
	.byte	$FF
	.byte	$FF
	.byte	$F8
	.byte	$F7
	.byte	$77
	.byte	$77
	.byte	$78
	.byte	$F7
	.byte	$88
	.byte	$88
	.byte	$78
	.byte	$F7
	.byte	$87
	.byte	$7F
	.byte	$78
	.byte	$F7
	.byte	$87
	.byte	$7F
	.byte	$78
	.byte	$F7
	.byte	$8F
	.byte	$FF
	.byte	$78
	.byte	$F7
	.byte	$77
	.byte	$77
	.byte	$78
	.byte	$F8
	.byte	$88
	.byte	$88
	.byte	$88
	.byte	$33
	.byte	$33
	.byte	$33
	.byte	$33
	.byte	$33
	.byte	$88
	.byte	$88
	.byte	$33
	.byte	$38
	.byte	$38
	.byte	$83
	.byte	$83
	.byte	$38
	.byte	$83
	.byte	$88
	.byte	$83
	.byte	$38
	.byte	$88
	.byte	$38
	.byte	$83
	.byte	$38
	.byte	$38
	.byte	$83
	.byte	$83
	.byte	$33
	.byte	$88
	.byte	$88
	.byte	$33
	.byte	$33
	.byte	$33
	.byte	$33
	.byte	$33
L0001:
	.byte	$4D,$41,$58,$00,$47,$41,$4D,$45,$00,$4F,$56,$45,$52,$00,$70,$72
	.byte	$65,$73,$73,$20,$55,$50,$20,$66,$6F,$72,$20,$6E,$65,$77,$20,$67
	.byte	$61,$6D,$65,$00

.segment	"BSS"

_campo:
	.res	336,$00
_oldc:
	.res	336,$00
_pieza:
	.res	16,$00
_piezas:
	.res	56,$00
_xp:
	.res	1,$00
_yp:
	.res	1,$00
_srand:
	.res	4,$00
_txtx:
	.res	1,$00
_txty:
	.res	1,$00
_posx:
	.res	1,$00
_posy:
	.res	1,$00

; ---------------------------------------------------------------
; void __near__ init_pt (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_init_pt: near

.segment	"CODE"

;
; pp=(uchar *)piezas;
;
	jsr     decsp5
	lda     #<(_piezas)
	ldx     #>(_piezas)
	ldy     #$01
	jsr     staxysp
;
; p=(uchar *)ptab;
;
	lda     #<(_ptab)
	ldx     #>(_ptab)
	ldy     #$03
	jsr     staxysp
;
; for (i=0;i<56;i++) *pp++=*p++;
;
	lda     #$00
	tay
L0558:	sta     (sp),y
	cmp     #$38
	jcs     incsp5
	ldy     #$02
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	sta     regsave
	stx     regsave+1
	clc
	adc     #$01
	bcc     L0052
	inx
L0052:	jsr     staxysp
	lda     regsave
	ldx     regsave+1
	jsr     pushax
	ldy     #$06
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	sta     regsave
	stx     regsave+1
	clc
	adc     #$01
	bcc     L0054
	inx
L0054:	jsr     staxysp
	ldy     #$00
	lda     (regsave),y
	jsr     staspidx
	ldy     #$00
	lda     (sp),y
	clc
	adc     #$01
	jmp     L0558

.endproc

; ---------------------------------------------------------------
; int __near__ rand (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_rand: near

.segment	"CODE"

;
; srand=srand* 1103515245 + 12345;
;
	lda     _srand+3
	sta     sreg+1
	lda     _srand+2
	sta     sreg
	ldx     _srand+1
	lda     _srand
	jsr     pusheax
	ldx     #$4E
	lda     #$C6
	sta     sreg
	lda     #$41
	sta     sreg+1
	lda     #$6D
	jsr     tosumuleax
	jsr     pusheax
	ldx     #$30
	lda     #$00
	lda     #$39
	jsr     tosadd0ax
	sta     _srand
	stx     _srand+1
	ldy     sreg
	sty     _srand+2
	ldy     sreg+1
	sty     _srand+3
;
; return (srand>>16)&0x7fff;
;
	lda     _srand+3
	sta     sreg+1
	lda     _srand+2
	sta     sreg
	ldy     #$00
	ldx     sreg+1
	lda     sreg
	jsr     push0ax
	ldx     #$7F
	lda     #$FF
	jmp     tosandeax

.endproc

; ---------------------------------------------------------------
; void __near__ cout (unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_cout: near

.segment	"RODATA"

L005C:
	.byte	$00
	.byte	$0F
	.byte	$F0
	.byte	$FF

.segment	"CODE"

;
; pd=(unsigned char *)0x4000;
;
	jsr     decsp6
	ldx     #$40
	lda     #$00
	ldy     #$02
	jsr     staxysp
;
; pd=&pd[txtx*5+txty*128*16];
;
	ldy     #$03
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     pushax
	ldx     #$00
	lda     _txtx
	jsr     mulax5
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     _txty
	jsr     shlax4
	jsr     shlax3
	jsr     shlax4
	clc
	adc     ptr1
	pha
	txa
	adc     ptr1+1
	tax
	pla
	jsr     tosaddax
	ldy     #$02
	jsr     staxysp
;
; ps=(unsigned char *)(0xE010+16*(a-32));
;
	lda     #$10
	jsr     pusha0
	ldy     #$08
	lda     (sp),y
	sec
	sbc     #$20
	bcs     L006A
	ldx     #$FF
L006A:	jsr     tosumulax
	clc
	adc     #$10
	pha
	txa
	adc     #$E0
	tax
	pla
	jsr     stax0sp
;
; for (i=0;i<16;i++) {
;
	lda     #$00
	ldy     #$05
L0559:	sta     (sp),y
	cmp     #$10
	jcs     L006C
;
; d=*ps++;
;
	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	sta     regsave
	stx     regsave+1
	clc
	adc     #$01
	bcc     L0075
	inx
L0075:	jsr     stax0sp
	ldy     #$00
	lda     (regsave),y
	ldy     #$04
	sta     (sp),y
;
; *pd++=dptab[d>>6];
;
	dey
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	sta     regsave
	stx     regsave+1
	clc
	adc     #$01
	bcc     L0077
	inx
L0077:	jsr     staxysp
	ldx     #$00
	ldy     #$04
	lda     (sp),y
	jsr     asrax4
	jsr     asrax2
	sta     ptr1
	txa
	clc
	adc     #>(L005C)
	sta     ptr1+1
	ldy     #<(L005C)
	lda     (ptr1),y
	ldy     #$00
	sta     (regsave),y
;
; *pd++=dptab[(d>>4)&3];
;
	ldy     #$03
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	sta     regsave
	stx     regsave+1
	clc
	adc     #$01
	bcc     L007B
	inx
L007B:	jsr     staxysp
	ldx     #$00
	ldy     #$04
	lda     (sp),y
	jsr     asrax4
	and     #$03
	sta     ptr1
	lda     #$00
	clc
	adc     #>(L005C)
	sta     ptr1+1
	ldy     #<(L005C)
	lda     (ptr1),y
	ldy     #$00
	sta     (regsave),y
;
; *pd++=dptab[(d>>2)&3];
;
	ldy     #$03
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	sta     regsave
	stx     regsave+1
	clc
	adc     #$01
	bcc     L0080
	inx
L0080:	jsr     staxysp
	ldx     #$00
	ldy     #$04
	lda     (sp),y
	jsr     asrax2
	and     #$03
	sta     ptr1
	lda     #$00
	clc
	adc     #>(L005C)
	sta     ptr1+1
	ldy     #<(L005C)
	lda     (ptr1),y
	ldy     #$00
	sta     (regsave),y
;
; *pd++=dptab[d&3];
;
	ldy     #$03
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	sta     regsave
	stx     regsave+1
	clc
	adc     #$01
	bcc     L0085
	inx
L0085:	jsr     staxysp
	ldy     #$04
	lda     (sp),y
	and     #$03
	sta     ptr1
	lda     #$00
	clc
	adc     #>(L005C)
	sta     ptr1+1
	ldy     #<(L005C)
	lda     (ptr1),y
	ldy     #$00
	sta     (regsave),y
;
; pd=&pd[128-4];
;
	ldy     #$03
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	clc
	adc     #$7C
	bcc     L008B
	inx
L008B:	jsr     staxysp
;
; for (i=0;i<16;i++) {
;
	ldy     #$05
	lda     (sp),y
	clc
	adc     #$01
	jmp     L0559
;
; txtx++;
;
L006C:	lda     _txtx
	clc
	adc     #$01
	sta     _txtx
;
; }
;
	jmp     incsp7

.endproc

; ---------------------------------------------------------------
; void __near__ puts (__near__ unsigned char*)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_puts: near

.segment	"CODE"

;
; while (*p) cout(*p++);
;
L008E:	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	jeq     incsp2
	iny
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	sta     regsave
	stx     regsave+1
	clc
	adc     #$01
	bcc     L0093
	inx
L0093:	jsr     stax0sp
	ldy     #$00
	lda     (regsave),y
	jsr     pusha
	jsr     _cout
	jmp     L008E

.endproc

; ---------------------------------------------------------------
; void __near__ delay16m (unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_delay16m: near

.segment	"CODE"

;
; for (;n;n--) {
;
L0095:	ldy     #$00
	lda     (sp),y
	jeq     incsp1
;
; while (!(STAT1&0x10));
;
L0098:	lda     $E002
	and     #$10
	beq     L0098
;
; while (STAT1&0x10);
;
L009C:	lda     $E002
	and     #$10
	bne     L009C
;
; srand++;
;
	lda     _srand+3
	sta     sreg+1
	lda     _srand+2
	sta     sreg
	ldx     _srand+1
	lda     _srand
	jsr     saveeax
	ldy     #$01
	jsr     inceaxy
	sta     _srand
	stx     _srand+1
	ldy     sreg
	sty     _srand+2
	ldy     sreg+1
	sty     _srand+3
	jsr     resteax
;
; for (;n;n--) {
;
	ldy     #$00
	lda     (sp),y
	sec
	sbc     #$01
	sta     (sp),y
	jmp     L0095

.endproc

; ---------------------------------------------------------------
; void __near__ prtnum (unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_prtnum: near

.segment	"CODE"

;
; cout('0'+x/100);
;
	ldx     #$00
	lda     (sp,x)
	jsr     pusha0
	lda     #$64
	jsr     tosudiva0
	clc
	adc     #$30
	jsr     pusha
	jsr     _cout
;
; cout('0'+(x/10)%10);
;
	ldx     #$00
	lda     (sp,x)
	jsr     pusha0
	lda     #$0A
	jsr     tosudiva0
	jsr     pushax
	lda     #$0A
	jsr     tosumoda0
	clc
	adc     #$30
	jsr     pusha
	jsr     _cout
;
; cout('0'+x%10);
;
	ldx     #$00
	lda     (sp,x)
	jsr     pusha0
	lda     #$0A
	jsr     tosumoda0
	clc
	adc     #$30
	jsr     pusha
	jsr     _cout
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ cuadro (unsigned char, unsigned char, unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_cuadro: near

.segment	"CODE"

;
; x+=10; // Centrado
;
	jsr     decsp6
	ldy     #$08
	clc
	lda     #$0A
	adc     (sp),y
	sta     (sp),y
;
; pd=(unsigned char *)0x4000;
;
	ldx     #$40
	lda     #$00
	ldy     #$02
	jsr     staxysp
;
; pd=&pd[x*4+y*128*8];
;
	tax
	ldy     #$08
	lda     (sp),y
	jsr     shlax2
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	dey
	lda     (sp),y
	jsr     shlax4
	jsr     shlax3
	jsr     shlax3
	clc
	adc     ptr1
	pha
	txa
	adc     ptr1+1
	tax
	pla
	clc
	ldy     #$02
	adc     (sp),y
	pha
	txa
	iny
	adc     (sp),y
	tax
	pla
	dey
	jsr     staxysp
;
; ps=(unsigned char *)&cuad[tipo*32];
;
	ldy     #$06
	ldx     #$00
	lda     (sp),y
	jsr     shlax4
	stx     tmp1
	asl     a
	rol     tmp1
	clc
	adc     #<(_cuad)
	tay
	lda     tmp1
	adc     #>(_cuad)
	tax
	tya
	jsr     stax0sp
;
; for (i=0;i<8;i++) {
;
	lda     #$00
	ldy     #$05
L055B:	sta     (sp),y
	cmp     #$08
	bcs     L01DD
;
; for (j=0;j<4;j++) *pd++=*ps++;
;
	lda     #$00
	dey
L055A:	sta     (sp),y
	cmp     #$04
	bcs     L01E5
	dey
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	sta     regsave
	stx     regsave+1
	clc
	adc     #$01
	bcc     L01ED
	inx
L01ED:	jsr     staxysp
	lda     regsave
	ldx     regsave+1
	jsr     pushax
	ldy     #$03
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	sta     regsave
	stx     regsave+1
	clc
	adc     #$01
	bcc     L01EF
	inx
L01EF:	jsr     staxysp
	ldy     #$00
	lda     (regsave),y
	jsr     staspidx
	ldy     #$04
	lda     (sp),y
	clc
	adc     #$01
	jmp     L055A
;
; pd=&pd[128-4];
;
L01E5:	dey
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	clc
	adc     #$7C
	bcc     L01F3
	inx
L01F3:	jsr     staxysp
;
; for (i=0;i<8;i++) {
;
	ldy     #$05
	lda     (sp),y
	clc
	adc     #$01
	jmp     L055B
;
; }
;
L01DD:	ldy     #$09
	jmp     addysp

.endproc

; ---------------------------------------------------------------
; signed char __near__ testpos (signed char, signed char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_testpos: near

.segment	"CODE"

;
; register signed char i,j;
;
	lda     regbank+5
	jsr     pusha
	lda     regbank+4
	jsr     pusha
;
; for (i=0;i<4;i++)
;
	lda     #$00
L055D:	sta     regbank+5
	sec
	sbc     #$04
	bvc     L01FD
	eor     #$80
L01FD:	jpl     L01F6
;
; for (j=0;j<4;j++) {
;
	lda     #$00
L055C:	sta     regbank+4
	sec
	sbc     #$04
	bvc     L0208
	eor     #$80
L0208:	jpl     L01F7
;
; if (x+j<0) continue;
;
	ldy     #$03
	ldx     #$00
	lda     (sp),y
	bpl     L020D
	dex
L020D:	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     regbank+4
	bpl     L020E
	dex
L020E:	clc
	adc     ptr1
	txa
	adc     ptr1+1
	tax
	cpx     #$80
	jcs     L0202
;
; if (x+j>ANCHO+1) continue;
;
	ldx     #$00
	lda     (sp),y
	bpl     L0211
	dex
L0211:	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     regbank+4
	bpl     L0212
	dex
L0212:	clc
	adc     ptr1
	pha
	txa
	adc     ptr1+1
	tax
	pla
	cmp     #$0C
	txa
	sbc     #$00
	bvs     L0213
	eor     #$80
L0213:	jmi     L0202
;
; if (y+i<0) continue;
;
	dey
	ldx     #$00
	lda     (sp),y
	bpl     L0216
	dex
L0216:	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     regbank+5
	bpl     L0217
	dex
L0217:	clc
	adc     ptr1
	txa
	adc     ptr1+1
	tax
	cpx     #$80
	jcs     L0202
;
; if (y+i>ALTO) continue;
;
	ldx     #$00
	lda     (sp),y
	bpl     L021A
	dex
L021A:	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     regbank+5
	bpl     L021B
	dex
L021B:	clc
	adc     ptr1
	pha
	txa
	adc     ptr1+1
	tax
	pla
	cmp     #$15
	txa
	sbc     #$00
	bvs     L021C
	eor     #$80
L021C:	jmi     L0202
;
; if (campo[y+i][x+j] && pieza[i][j]) return 1;
;
	ldx     #$00
	lda     (sp),y
	bpl     L0220
	dex
L0220:	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     regbank+5
	bpl     L0221
	dex
L0221:	clc
	adc     ptr1
	pha
	txa
	adc     ptr1+1
	tax
	pla
	jsr     aslax4
	clc
	adc     #<(_campo)
	sta     sreg
	txa
	adc     #>(_campo)
	sta     sreg+1
	ldx     #$00
	iny
	lda     (sp),y
	bpl     L0223
	dex
L0223:	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     regbank+4
	bpl     L0224
	dex
L0224:	clc
	adc     ptr1
	pha
	txa
	adc     ptr1+1
	tax
	pla
	clc
	adc     sreg
	sta     ptr1
	txa
	adc     sreg+1
	sta     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	beq     L0202
	ldx     #$00
	lda     regbank+5
	bpl     L0227
	dex
L0227:	jsr     aslax2
	clc
	adc     #<(_pieza)
	sta     ptr1
	txa
	adc     #>(_pieza)
	sta     ptr1+1
	ldx     #$00
	lda     regbank+4
	bpl     L0229
	dex
L0229:	clc
	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	sta     ptr1+1
	lda     (ptr1),y
	beq     L0202
	ldx     #$00
	lda     #$01
	jmp     L01F4
;
; for (j=0;j<4;j++) {
;
L0202:	lda     regbank+4
	clc
	adc     #$01
	jmp     L055C
;
; for (i=0;i<4;i++)
;
L01F7:	lda     regbank+5
	clc
	adc     #$01
	jmp     L055D
;
; return 0;
;
L01F6:	ldx     #$00
	txa
;
; }
;
L01F4:	pha
	lda     (sp,x)
	sta     regbank+4
	ldy     #$01
	lda     (sp),y
	sta     regbank+5
	pla
	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; void __near__ rota (signed char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_rota: near

.segment	"CODE"

;
; register unsigned char i,j;
;
	lda     regbank+5
	jsr     pusha
	lda     regbank+4
	jsr     pusha
;
; if (giro>0) {  //Giro antihorario de 90º
;
	ldy     #$10
	jsr     subysp
	ldy     #$12
	lda     (sp),y
	sec
	sbc     #$01
	bvs     L0233
	eor     #$80
L0233:	jpl     L024B
;
; for (i=0;i<4;i++)
;
	lda     #$00
L0567:	sta     regbank+5
	cmp     #$04
	bcs     L0235
;
; for (j=0;j<4;j++) tmp[3-j][i]=pieza[i][j];
;
	lda     #$00
L0566:	sta     regbank+4
	cmp     #$04
	bcs     L0236
	lda     #$03
	sec
	sbc     regbank+4
	ldx     #$00
	jsr     aslax2
	clc
	adc     sp
	tay
	txa
	adc     sp+1
	tax
	tya
	clc
	adc     regbank+5
	bcc     L055E
	inx
L055E:	sta     sreg
	stx     sreg+1
	ldx     #$00
	lda     regbank+5
	jsr     aslax2
	clc
	adc     #<(_pieza)
	sta     ptr1
	txa
	adc     #>(_pieza)
	sta     ptr1+1
	ldy     regbank+4
	lda     (ptr1),y
	ldy     #$00
	sta     (sreg),y
	lda     regbank+4
	clc
	adc     #$01
	jmp     L0566
;
; for (i=0;i<4;i++)
;
L0236:	lda     regbank+5
	clc
	adc     #$01
	jmp     L0567
;
; for (i=0;i<4;i++)
;
L0235:	lda     #$00
L0569:	sta     regbank+5
	cmp     #$04
	bcs     L024B
;
; for (j=0;j<4;j++) pieza[i][j]=tmp[i][j];
;
	lda     #$00
L0568:	sta     regbank+4
	cmp     #$04
	bcs     L024C
	ldx     #$00
	lda     regbank+5
	jsr     aslax2
	clc
	adc     #<(_pieza)
	tay
	txa
	adc     #>(_pieza)
	tax
	tya
	clc
	adc     regbank+4
	bcc     L0560
	inx
L0560:	jsr     pushax
	ldx     #$00
	lda     regbank+5
	jsr     aslax2
	clc
	adc     #$02
	bcc     L025F
	inx
	clc
L025F:	adc     sp
	sta     ptr1
	txa
	adc     sp+1
	sta     ptr1+1
	ldy     regbank+4
	lda     (ptr1),y
	ldy     #$00
	jsr     staspidx
	lda     regbank+4
	clc
	adc     #$01
	jmp     L0568
;
; for (i=0;i<4;i++)
;
L024C:	lda     regbank+5
	clc
	adc     #$01
	jmp     L0569
;
; if (giro<0) {  //Giro horario de 90º
;
L024B:	ldy     #$12
	lda     (sp),y
	asl     a
	jcc     L027B
;
; for (i=0;i<4;i++)
;
	lda     #$00
L056B:	sta     regbank+5
	cmp     #$04
	bcs     L0265
;
; for (j=0;j<4;j++) tmp[j][3-i]=pieza[i][j];
;
	lda     #$00
L056A:	sta     regbank+4
	cmp     #$04
	bcs     L0266
	ldx     #$00
	lda     regbank+4
	jsr     aslax2
	clc
	adc     sp
	sta     ptr1
	txa
	adc     sp+1
	sta     ptr1+1
	lda     #$03
	sec
	sbc     regbank+5
	clc
	adc     ptr1
	ldx     ptr1+1
	bcc     L0565
	inx
L0565:	sta     sreg
	stx     sreg+1
	ldx     #$00
	lda     regbank+5
	jsr     aslax2
	clc
	adc     #<(_pieza)
	sta     ptr1
	txa
	adc     #>(_pieza)
	sta     ptr1+1
	ldy     regbank+4
	lda     (ptr1),y
	ldy     #$00
	sta     (sreg),y
	lda     regbank+4
	clc
	adc     #$01
	jmp     L056A
;
; for (i=0;i<4;i++)
;
L0266:	lda     regbank+5
	clc
	adc     #$01
	jmp     L056B
;
; for (i=0;i<4;i++)
;
L0265:	lda     #$00
L056D:	sta     regbank+5
	cmp     #$04
	bcs     L027B
;
; for (j=0;j<4;j++) pieza[i][j]=tmp[i][j];
;
	lda     #$00
L056C:	sta     regbank+4
	cmp     #$04
	bcs     L027C
	ldx     #$00
	lda     regbank+5
	jsr     aslax2
	clc
	adc     #<(_pieza)
	tay
	txa
	adc     #>(_pieza)
	tax
	tya
	clc
	adc     regbank+4
	bcc     L0563
	inx
L0563:	jsr     pushax
	ldx     #$00
	lda     regbank+5
	jsr     aslax2
	clc
	adc     #$02
	bcc     L028F
	inx
	clc
L028F:	adc     sp
	sta     ptr1
	txa
	adc     sp+1
	sta     ptr1+1
	ldy     regbank+4
	lda     (ptr1),y
	ldy     #$00
	jsr     staspidx
	lda     regbank+4
	clc
	adc     #$01
	jmp     L056C
;
; for (i=0;i<4;i++)
;
L027C:	lda     regbank+5
	clc
	adc     #$01
	jmp     L056D
;
; }
;
L027B:	ldy     #$10
	lda     (sp),y
	sta     regbank+4
	iny
	lda     (sp),y
	sta     regbank+5
	ldy     #$13
	jmp     addysp

.endproc

; ---------------------------------------------------------------
; void __near__ init (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_init: near

.segment	"CODE"

;
; register unsigned char i,j;
;
	lda     regbank+5
	jsr     pusha
	lda     regbank+4
	jsr     pusha
;
; for (i=0;i<ALTO;i++) {
;
	lda     #$00
L0573:	sta     regbank+5
	cmp     #$14
	bcs     L0293
;
; for (j=1;j<ANCHO+1;j++) campo[i][j]=0;
;
	lda     #$01
L0572:	sta     regbank+4
	cmp     #$0B
	bcs     L029B
	ldx     #$00
	lda     regbank+5
	jsr     aslax4
	clc
	adc     #<(_campo)
	tay
	txa
	adc     #>(_campo)
	tax
	tya
	clc
	adc     regbank+4
	bcc     L056E
	inx
L056E:	sta     ptr1
	stx     ptr1+1
	lda     #$00
	tay
	sta     (ptr1),y
	lda     regbank+4
	clc
	adc     #$01
	jmp     L0572
;
; campo[i][0]=campo[i][ANCHO+1]=8;
;
L029B:	ldx     #$00
	lda     regbank+5
	jsr     aslax4
	clc
	adc     #<(_campo)
	tay
	txa
	adc     #>(_campo)
	tax
	tya
	jsr     pushax
	ldx     #$00
	lda     regbank+5
	jsr     aslax4
	clc
	adc     #<(_campo)
	sta     ptr1
	txa
	adc     #>(_campo)
	sta     ptr1+1
	lda     #$08
	ldy     #$0B
	sta     (ptr1),y
	ldy     #$00
	jsr     staspidx
;
; for (i=0;i<ALTO;i++) {
;
	lda     regbank+5
	clc
	adc     #$01
	jmp     L0573
;
; for (j=0;j<ANCHO+2;j++) campo[i][j]=8;
;
L0293:	lda     #$00
L0574:	sta     regbank+4
	cmp     #$0C
	bcs     L02AE
	ldx     #$00
	lda     regbank+5
	jsr     aslax4
	clc
	adc     #<(_campo)
	tay
	txa
	adc     #>(_campo)
	tax
	tya
	clc
	adc     regbank+4
	bcc     L056F
	inx
L056F:	sta     ptr1
	stx     ptr1+1
	lda     #$08
	ldy     #$00
	sta     (ptr1),y
	lda     regbank+4
	clc
	adc     #$01
	jmp     L0574
;
; for (i=0;i<ALTO+1;i++) for(j=0;j<ANCHO+2;j++) oldc[i][j]=0xff;
;
L02AE:	lda     #$00
L0576:	sta     regbank+5
	cmp     #$15
	bcs     L02BA
	lda     #$00
L0575:	sta     regbank+4
	cmp     #$0C
	bcs     L02BB
	ldx     #$00
	lda     regbank+5
	jsr     aslax4
	clc
	adc     #<(_oldc)
	tay
	txa
	adc     #>(_oldc)
	tax
	tya
	clc
	adc     regbank+4
	bcc     L0570
	inx
L0570:	sta     ptr1
	stx     ptr1+1
	lda     #$FF
	ldy     #$00
	sta     (ptr1),y
	lda     regbank+4
	clc
	adc     #$01
	jmp     L0575
L02BB:	lda     regbank+5
	clc
	adc     #$01
	jmp     L0576
;
; for (i=0;i<4;i++) for (j=0;j<4;j++) pieza[i][j]=0;
;
L02BA:	lda     #$00
L0578:	sta     regbank+5
	cmp     #$04
	bcs     L02CE
	lda     #$00
L0577:	sta     regbank+4
	cmp     #$04
	bcs     L02CF
	ldx     #$00
	lda     regbank+5
	jsr     aslax2
	clc
	adc     #<(_pieza)
	tay
	txa
	adc     #>(_pieza)
	tax
	tya
	clc
	adc     regbank+4
	bcc     L0571
	inx
L0571:	sta     ptr1
	stx     ptr1+1
	lda     #$00
	tay
	sta     (ptr1),y
	lda     regbank+4
	clc
	adc     #$01
	jmp     L0577
L02CF:	lda     regbank+5
	clc
	adc     #$01
	jmp     L0578
;
; xp=4; yp=-4;
;
L02CE:	lda     #$04
	sta     _xp
	lda     #$FC
	sta     _yp
;
; cls();
;
	ldy     #$00
	jsr     _cls
;
; }
;
	ldy     #$00
	lda     (sp),y
	sta     regbank+4
	iny
	lda     (sp),y
	sta     regbank+5
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ display (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_display: near

.segment	"CODE"

;
; register signed char i,j,ip,jp,ch;
;
	lda     regbank+5
	jsr     pusha
	lda     regbank+4
	jsr     pusha
	lda     regbank+3
	jsr     pusha
	lda     regbank+2
	jsr     pusha
	lda     regbank+1
	jsr     pusha
;
; for (i=0;i<ALTO+1;i++) {
;
	lda     #$00
L057C:	sta     regbank+5
	sec
	sbc     #$15
	bvc     L02EF
	eor     #$80
L02EF:	jpl     L02E8
;
; for (j=0;j<ANCHO+2;j++) {
;
	lda     #$00
L057B:	sta     regbank+4
	sec
	sbc     #$0C
	bvc     L02FA
	eor     #$80
L02FA:	jpl     L02E9
;
; ch=0;
;
	lda     #$00
	sta     regbank+1
;
; if (campo[i][j]) ch=campo[i][j];
;
	tax
	lda     regbank+5
	bpl     L0302
	dex
L0302:	jsr     aslax4
	clc
	adc     #<(_campo)
	sta     ptr1
	txa
	adc     #>(_campo)
	sta     ptr1+1
	ldx     #$00
	lda     regbank+4
	bpl     L0304
	dex
L0304:	clc
	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	sta     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	beq     L02FF
	ldx     #$00
	lda     regbank+5
	bpl     L0308
	dex
L0308:	jsr     aslax4
	clc
	adc     #<(_campo)
	sta     ptr1
	txa
	adc     #>(_campo)
	sta     ptr1+1
	ldx     #$00
	lda     regbank+4
	bpl     L030A
	dex
L030A:	clc
	adc     ptr1
	pha
	txa
	adc     ptr1+1
	tax
	pla
	jsr     ldaidx
	sta     regbank+1
;
; ip=i-yp;
;
L02FF:	ldx     #$00
	lda     regbank+5
	bpl     L030D
	dex
L030D:	jsr     pushax
	ldx     #$00
	lda     _yp
	bpl     L030E
	dex
L030E:	jsr     tossubax
	sta     regbank+3
;
; if (ip>=0 && ip<4) {
;
	tax
	jmi     L0321
	lda     regbank+3
	sec
	sbc     #$04
	bvc     L0314
	eor     #$80
L0314:	bpl     L0321
;
; jp=j-xp;
;
	ldx     #$00
	lda     regbank+4
	bpl     L0318
	dex
L0318:	jsr     pushax
	ldx     #$00
	lda     _xp
	bpl     L0319
	dex
L0319:	jsr     tossubax
	sta     regbank+2
;
; if (jp>=0 && jp<4) if (pieza[ip][jp]) ch=pieza[ip][jp];
;
	tax
	bmi     L0321
	lda     regbank+2
	sec
	sbc     #$04
	bvc     L031F
	eor     #$80
L031F:	bpl     L0321
	ldx     #$00
	lda     regbank+3
	bpl     L0324
	dex
L0324:	jsr     aslax2
	clc
	adc     #<(_pieza)
	sta     ptr1
	txa
	adc     #>(_pieza)
	sta     ptr1+1
	ldx     #$00
	lda     regbank+2
	bpl     L0326
	dex
L0326:	clc
	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	sta     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	beq     L0321
	ldx     #$00
	lda     regbank+3
	bpl     L032A
	dex
L032A:	jsr     aslax2
	clc
	adc     #<(_pieza)
	sta     ptr1
	txa
	adc     #>(_pieza)
	sta     ptr1+1
	ldx     #$00
	lda     regbank+2
	bpl     L032C
	dex
L032C:	clc
	adc     ptr1
	pha
	txa
	adc     ptr1+1
	tax
	pla
	jsr     ldaidx
	sta     regbank+1
;
; if (oldc[i][j]!=ch) {
;
L0321:	ldx     #$00
	lda     regbank+5
	bpl     L0330
	dex
L0330:	jsr     aslax4
	clc
	adc     #<(_oldc)
	sta     ptr1
	txa
	adc     #>(_oldc)
	sta     ptr1+1
	ldx     #$00
	lda     regbank+4
	bpl     L0332
	dex
L0332:	clc
	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	sta     ptr1+1
	ldy     #$00
	ldx     #$00
	lda     (ptr1),y
	sta     ptr1
	stx     ptr1+1
	lda     regbank+1
	bpl     L0333
	dex
L0333:	cpx     ptr1+1
	bne     L057A
	cmp     ptr1
	beq     L02F4
;
; oldc[i][j]=ch;
;
L057A:	ldx     #$00
	lda     regbank+5
	bpl     L0336
	dex
L0336:	jsr     aslax4
	clc
	adc     #<(_oldc)
	sta     ptr1
	txa
	adc     #>(_oldc)
	sta     ptr1+1
	ldx     #$00
	lda     regbank+4
	bpl     L0338
	dex
L0338:	clc
	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	sta     ptr1+1
	lda     regbank+1
	sta     (ptr1),y
;
; cuadro(j,i,ch);
;
	jsr     decsp3
	lda     regbank+4
	ldy     #$02
	sta     (sp),y
	lda     regbank+5
	dey
	sta     (sp),y
	lda     regbank+1
	dey
	sta     (sp),y
	jsr     _cuadro
;
; for (j=0;j<ANCHO+2;j++) {
;
L02F4:	lda     regbank+4
	clc
	adc     #$01
	jmp     L057B
;
; for (i=0;i<ALTO+1;i++) {
;
L02E9:	lda     regbank+5
	clc
	adc     #$01
	jmp     L057C
;
; }
;
L02E8:	ldy     #$00
L033E:	lda     (sp),y
	sta     regbank+1,y
	iny
	cpy     #$05
	bne     L033E
	jmp     incsp5

.endproc

; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"RODATA"

L0342:
	.byte	$00
	.byte	$00
	.byte	$0A
	.byte	$10
	.byte	$A0
	.byte	$20
	.byte	$AA
	.byte	$30
	.byte	$00
	.byte	$4A
	.byte	$0A
	.byte	$5A
	.byte	$A0
	.byte	$6A
	.byte	$AA
	.byte	$7A
	.byte	$55
	.byte	$85
	.byte	$5F
	.byte	$95
	.byte	$F5
	.byte	$A5
	.byte	$FF
	.byte	$B5
	.byte	$55
	.byte	$CF
	.byte	$5F
	.byte	$DF
	.byte	$F5
	.byte	$EF
	.byte	$FF
	.byte	$FF

.segment	"CODE"

;
; register signed char i,j,k,np,sigp,del,dl,npiezas,nlineas,max;
;
	lda     regbank+5
	jsr     pusha
	lda     regbank+4
	jsr     pusha
	lda     regbank+3
	jsr     pusha
	lda     regbank+2
	jsr     pusha
	lda     regbank+1
	jsr     pusha
	lda     regbank+0
	jsr     pusha
;
; CTRL2=3; // Modo color 
;
	ldy     #$0B
	jsr     subysp
	lda     #$03
	sta     $E003
;
; IOCHAN=0x03; // Sin salida por UART ni video (sin cursor)
;
	sta     $0018
;
; pag[0]=PAGE2;
;
	lda     $E00A
	ldy     #$00
	sta     (sp),y
;
; pag[1]=PAGE3;
;
	lda     $E00B
	iny
	sta     (sp),y
;
; pag[2]=PAGE4;
;
	lda     $E00C
	iny
	sta     (sp),y
;
; pag[3]=PAGE5;
;
	lda     $E00D
	iny
	sta     (sp),y
;
; PAGE2=0;
;
	lda     #$00
	sta     $E00A
;
; PAGE3=1;
;
	lda     #$01
	sta     $E00B
;
; PAGE4=2;
;
	lda     #$02
	sta     $E00C
;
; PAGE5=3;
;
	sty     $E00D
;
; for (i=0,p=(unsigned char *)mypal;i<16;i++) {
;
	lda     #$00
	sta     regbank+5
	lda     #<(L0342)
	ldx     #>(L0342)
	iny
	jsr     staxysp
L0385:	lda     regbank+5
	sec
	sbc     #$10
	bvc     L038F
	eor     #$80
L038F:	bpl     L0386
;
; PAL0=*p++;
;
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	sta     regsave
	stx     regsave+1
	clc
	adc     #$01
	bcc     L0395
	inx
L0395:	jsr     staxysp
	ldy     #$00
	lda     (regsave),y
	sta     $E005
;
; PAL1=*p++;
;
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	sta     regsave
	stx     regsave+1
	clc
	adc     #$01
	bcc     L0399
	inx
L0399:	jsr     staxysp
	ldy     #$00
	lda     (regsave),y
	sta     $E006
;
; for (i=0,p=(unsigned char *)mypal;i<16;i++) {
;
	lda     regbank+5
	clc
	adc     #$01
	sta     regbank+5
	jmp     L0385
;
; BORDER=0;
;
L0386:	lda     #$00
	sta     $E001
;
; init_pt();
;
	jsr     _init_pt
;
; max=0;
;
	lda     #$00
	ldy     #$07
	sta     (sp),y
;
; init();
;
L03A0:	jsr     _init
;
; display();
;
	jsr     _display
;
; sigp=rand()%7;
;
	jsr     _rand
	jsr     pushax
	ldx     #$00
	lda     #$07
	jsr     tosmoda0
	sta     regbank+1
;
; npiezas=nlineas=0;
;
	lda     #$00
	ldy     #$08
	sta     (sp),y
	iny
	sta     (sp),y
;
; txtx=19; txty=6; puts("MAX");
;
	lda     #$13
	sta     _txtx
	lda     #$06
	sta     _txty
	lda     #<(L0001)
	ldx     #>(L0001)
	jsr     pushax
	jsr     _puts
;
; txtx=19; txty=7; prtnum(max);
;
	lda     #$13
	sta     _txtx
	lda     #$07
	sta     _txty
	tay
	lda     (sp),y
	jsr     pusha
	jsr     _prtnum
;
; npiezas++;
;
L03B9:	ldy     #$09
	lda     (sp),y
	clc
	adc     #$01
	sta     (sp),y
;
; np=sigp;
;
	lda     regbank+1
	sta     regbank+2
;
; sigp=rand()%7;
;
	jsr     _rand
	jsr     pushax
	ldx     #$00
	lda     #$07
	jsr     tosmoda0
	sta     regbank+1
;
; for (i=0;i<2;i++)
;
	lda     #$00
L057E:	sta     regbank+5
	sec
	sbc     #$02
	bvc     L03C9
	eor     #$80
L03C9:	bpl     L03C2
;
; for(j=0;j<4;j++)
;
	lda     #$00
L057D:	sta     regbank+4
	sec
	sbc     #$04
	bvc     L03D4
	eor     #$80
L03D4:	bpl     L03C3
;
; cuadro(ANCHO+3+j,i,piezas[sigp][i][j]);
;
	jsr     decsp3
	lda     regbank+4
	clc
	adc     #$0D
	ldy     #$02
	sta     (sp),y
	lda     regbank+5
	dey
	sta     (sp),y
	ldx     #$00
	lda     regbank+1
	bpl     L03DE
	dex
L03DE:	jsr     aslax3
	clc
	adc     #<(_piezas)
	sta     ptr1
	txa
	adc     #>(_piezas)
	sta     ptr1+1
	ldx     #$00
	lda     regbank+5
	bpl     L03E0
	dex
L03E0:	jsr     aslax2
	clc
	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	sta     ptr1+1
	ldx     #$00
	lda     regbank+4
	bpl     L03E2
	dex
L03E2:	clc
	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	sta     ptr1+1
	dey
	lda     (ptr1),y
	sta     (sp),y
	jsr     _cuadro
;
; for(j=0;j<4;j++)
;
	lda     regbank+4
	clc
	adc     #$01
	jmp     L057D
;
; for (i=0;i<2;i++)
;
L03C3:	lda     regbank+5
	clc
	adc     #$01
	jmp     L057E
;
; for (i=0;i<4;i++)
;
L03C2:	lda     #$00
L0580:	sta     regbank+5
	sec
	sbc     #$04
	bvc     L03EB
	eor     #$80
L03EB:	jpl     L03E4
;
; for (j=0;j<4;j++)
;
	lda     #$00
L057F:	sta     regbank+4
	sec
	sbc     #$04
	bvc     L03F6
	eor     #$80
L03F6:	jpl     L03E5
;
; pieza[i][j]=(i==0 || i==3)?0:piezas[np][i-1][j];
;
	ldx     #$00
	lda     regbank+5
	bpl     L03FB
	dex
L03FB:	jsr     aslax2
	clc
	adc     #<(_pieza)
	sta     ptr1
	txa
	adc     #>(_pieza)
	sta     ptr1+1
	ldx     #$00
	lda     regbank+4
	bpl     L03FD
	dex
L03FD:	clc
	adc     ptr1
	sta     sreg
	txa
	adc     ptr1+1
	sta     sreg+1
	lda     regbank+5
	beq     L03FF
	lda     regbank+5
	cmp     #$03
	bne     L0403
L03FF:	lda     #$00
	jmp     L0405
L0403:	ldx     #$00
	lda     regbank+2
	bpl     L0408
	dex
L0408:	jsr     aslax3
	clc
	adc     #<(_piezas)
	sta     ptr1
	txa
	adc     #>(_piezas)
	sta     ptr1+1
	ldx     #$00
	lda     regbank+5
	bpl     L040A
	dex
L040A:	sec
	sbc     #$01
	bcs     L040B
	dex
L040B:	jsr     aslax2
	clc
	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	sta     ptr1+1
	ldx     #$00
	lda     regbank+4
	bpl     L040D
	dex
L040D:	clc
	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	sta     ptr1+1
	ldy     #$00
	lda     (ptr1),y
L0405:	ldy     #$00
	sta     (sreg),y
;
; for (j=0;j<4;j++)
;
	lda     regbank+4
	clc
	adc     #$01
	jmp     L057F
;
; for (i=0;i<4;i++)
;
L03E5:	lda     regbank+5
	clc
	adc     #$01
	jmp     L0580
;
; xp=4; yp=-2;
;
L03E4:	lda     #$04
	sta     _xp
	lda     #$FE
	sta     _yp
;
; if (testpos(xp,yp)) break;
;
	jsr     decsp2
	lda     _xp
	ldy     #$01
	sta     (sp),y
	lda     _yp
	dey
	sta     (sp),y
	jsr     _testpos
	tax
	jne     L03B7
;
; del=INIDEL-nlineas/DELSTEP; if (del<1) del=1; dl=del;
;
	lda     #$0F
	jsr     pusha0
	ldy     #$0A
	lda     (sp),y
	bpl     L0418
	ldx     #$FF
L0418:	jsr     pushax
	lda     #$0A
	jsr     tosdiva0
	jsr     tossubax
	sta     regbank+0
	sec
	sbc     #$01
	bvc     L041C
	eor     #$80
L041C:	bpl     L0419
	lda     #$01
	sta     regbank+0
L0419:	lda     regbank+0
	ldy     #$0A
	sta     (sp),y
;
; np=0;
;
L0425:	lda     #$00
	sta     regbank+2
;
; switch(cinnb()) {
;
	tay
	jsr     _cinnb
;
; }
;
	cmp     #$20
	jeq     L0456
	cmp     #$41
	jeq     L0448
	cmp     #$42
	jeq     L0456
	cmp     #$43
	beq     L043A
	cmp     #$44
	beq     L042C
	cmp     #$70
	jeq     L0469
	cmp     #$71
	jeq     L0471
	cmp     #$90
	beq     L0448
	cmp     #$91
	jeq     L0456
	cmp     #$92
	beq     L042C
	cmp     #$93
	beq     L043A
	jmp     L042A
;
; case 0x92: if (!testpos(xp-1,yp)) xp--;
;
L042C:	jsr     decsp2
	lda     _xp
	sec
	sbc     #$01
	ldy     #$01
	sta     (sp),y
	lda     _yp
	dey
	sta     (sp),y
	jsr     _testpos
	tax
	bne     L042F
	lda     _xp
	sec
	sbc     #$01
	sta     _xp
;
; np=1;
;
L042F:	lda     #$01
	sta     regbank+2
;
; break;
;
	jmp     L042A
;
; case 0x93: if (!testpos(xp+1,yp)) xp++;
;
L043A:	jsr     decsp2
	lda     _xp
	clc
	adc     #$01
	ldy     #$01
	sta     (sp),y
	lda     _yp
	dey
	sta     (sp),y
	jsr     _testpos
	tax
	bne     L043D
	lda     _xp
	clc
	adc     #$01
	sta     _xp
;
; np=1;break;
;
L043D:	lda     #$01
	sta     regbank+2
	jmp     L042A
;
; case 0x90: rota(1);
;
L0448:	lda     #$01
	jsr     pusha
	jsr     _rota
;
; if(testpos(xp,yp)) rota(-1);
;
	jsr     decsp2
	lda     _xp
	ldy     #$01
	sta     (sp),y
	lda     _yp
	dey
	sta     (sp),y
	jsr     _testpos
	tax
	beq     L044D
	lda     #$FF
	jsr     pusha
	jsr     _rota
;
; np=1;
;
L044D:	lda     #$01
	sta     regbank+2
;
; break;
;
	jmp     L042A
;
; case 0x91: while (!testpos(xp,yp+1)) {
;
L0456:	jsr     decsp2
	lda     _xp
	ldy     #$01
	sta     (sp),y
	lda     _yp
	clc
	adc     #$01
	dey
	sta     (sp),y
	jsr     _testpos
	tax
	bne     L0423
;
; yp++;
;
	lda     _yp
	clc
	adc     #$01
	sta     _yp
;
; display();
;
	jsr     _display
;
; delay16m(3);
;
	lda     #$03
	jsr     pusha
	jsr     _delay16m
;
; }
;
	jmp     L0456
;
; case 'p': while(cinnb()!='p') delay16m(3);
;
L0469:	ldy     #$00
	jsr     _cinnb
	cmp     #$70
	beq     L042A
	lda     #$03
	jsr     pusha
	jsr     _delay16m
	jmp     L0469
;
; if (!(--dl)) { // ABAJO
;
L042A:	ldy     #$0A
	lda     (sp),y
	sec
	sbc     #$01
	sta     (sp),y
	jsr     bnega
	beq     L0472
;
; dl=del;
;
	lda     regbank+0
	sta     (sp),y
;
; if (testpos(xp,yp+1)) break;
;
	jsr     decsp2
	lda     _xp
	ldy     #$01
	sta     (sp),y
	lda     _yp
	clc
	adc     #$01
	dey
	sta     (sp),y
	jsr     _testpos
	tax
	bne     L0423
;
; yp++;
;
	lda     _yp
	clc
	adc     #$01
	sta     _yp
;
; np=1;
;
	lda     #$01
	sta     regbank+2
;
; if (np) display();
;
L0472:	lda     regbank+2
	beq     L0483
	jsr     _display
;
; delay16m(3);
;
L0483:	lda     #$03
	jsr     pusha
	jsr     _delay16m
;
; }
;
	jmp     L0425
;
; for (i=0;i<4;i++) {
;
L0423:	lda     #$00
L0582:	sta     regbank+5
	sec
	sbc     #$04
	bvc     L0490
	eor     #$80
L0490:	jpl     L0489
;
; if (yp+i>=0 && yp+i<ALTO) {
;
	ldx     #$00
	lda     _yp
	bpl     L0495
	dex
L0495:	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     regbank+5
	bpl     L0496
	dex
L0496:	clc
	adc     ptr1
	txa
	adc     ptr1+1
	jmi     L048A
	ldx     #$00
	lda     _yp
	bpl     L0498
	dex
L0498:	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     regbank+5
	bpl     L0499
	dex
L0499:	clc
	adc     ptr1
	pha
	txa
	adc     ptr1+1
	tax
	pla
	cmp     #$14
	txa
	sbc     #$00
	bvc     L049A
	eor     #$80
L049A:	jpl     L048A
;
; p=&campo[yp+i][xp];
;
	ldx     #$00
	lda     _yp
	bpl     L049F
	dex
L049F:	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     regbank+5
	bpl     L04A0
	dex
L04A0:	clc
	adc     ptr1
	pha
	txa
	adc     ptr1+1
	tax
	pla
	jsr     aslax4
	clc
	adc     #<(_campo)
	sta     ptr1
	txa
	adc     #>(_campo)
	sta     ptr1+1
	ldx     #$00
	lda     _xp
	bpl     L04A2
	dex
L04A2:	clc
	adc     ptr1
	pha
	txa
	adc     ptr1+1
	tax
	pla
	ldy     #$04
	jsr     staxysp
;
; for (j=0;j<4;j++) {
;
	lda     #$00
L0581:	sta     regbank+4
	sec
	sbc     #$04
	bvc     L04AB
	eor     #$80
L04AB:	jpl     L048A
;
; if (xp+j>0 && xp+j<ANCHO+1){
;
	ldx     #$00
	lda     _xp
	bpl     L04B0
	dex
L04B0:	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     regbank+4
	bpl     L04B1
	dex
L04B1:	clc
	adc     ptr1
	pha
	txa
	adc     ptr1+1
	tax
	pla
	cmp     #$01
	txa
	sbc     #$00
	bvs     L04B2
	eor     #$80
L04B2:	bpl     L04B8
	ldx     #$00
	lda     _xp
	bpl     L04B4
	dex
L04B4:	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     regbank+4
	bpl     L04B5
	dex
L04B5:	clc
	adc     ptr1
	pha
	txa
	adc     ptr1+1
	tax
	pla
	cmp     #$0B
	txa
	sbc     #$00
	bvc     L04B6
	eor     #$80
L04B6:	bpl     L04B8
;
; if (!(*p)) *p=pieza[i][j];
;
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	bne     L04B8
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	sta     sreg
	stx     sreg+1
	ldx     #$00
	lda     regbank+5
	bpl     L04BE
	dex
L04BE:	jsr     aslax2
	clc
	adc     #<(_pieza)
	sta     ptr1
	txa
	adc     #>(_pieza)
	sta     ptr1+1
	ldx     #$00
	lda     regbank+4
	bpl     L04C0
	dex
L04C0:	clc
	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	sta     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	sta     (sreg),y
;
; p++;
;
L04B8:	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	clc
	adc     #$01
	bcc     L04C2
	inx
L04C2:	jsr     staxysp
;
; for (j=0;j<4;j++) {
;
	lda     regbank+4
	clc
	adc     #$01
	jmp     L0581
;
; for (i=0;i<4;i++) {
;
L048A:	lda     regbank+5
	clc
	adc     #$01
	jmp     L0582
;
; xp=yp=-4;
;
L0489:	lda     #$FC
	sta     _yp
	sta     _xp
;
; for (i=0;i<ALTO;i++) {
;
	lda     #$00
L0586:	sta     regbank+5
	sec
	sbc     #$14
	bvc     L04CE
	eor     #$80
L04CE:	jpl     L03B9
;
; for (j=1;j<ANCHO+1;j++) if (!campo[i][j]) break;
;
	lda     #$01
L0583:	sta     regbank+4
	sec
	sbc     #$0B
	bvc     L04D9
	eor     #$80
L04D9:	bpl     L04D2
	ldx     #$00
	lda     regbank+5
	bpl     L04DF
	dex
L04DF:	jsr     aslax4
	clc
	adc     #<(_campo)
	sta     ptr1
	txa
	adc     #>(_campo)
	sta     ptr1+1
	ldx     #$00
	lda     regbank+4
	bpl     L04E1
	dex
L04E1:	clc
	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	sta     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	beq     L04D2
	lda     regbank+4
	clc
	adc     #$01
	jmp     L0583
;
; if (j==ANCHO+1) { // Linea completa: Scroll hacia abajo
;
L04D2:	lda     regbank+4
	cmp     #$0B
	jne     L04C8
;
; for (j=1;j<ANCHO+1;j++)
;
	lda     #$01
L0585:	sta     regbank+4
	sec
	sbc     #$0B
	bvc     L04ED
	eor     #$80
L04ED:	bpl     L04E6
;
; for (k=i;k>=0;k--)
;
	lda     regbank+5
L0584:	sta     regbank+3
	tax
	bmi     L04E7
;
; campo[k][j]=(k)?campo[k-1][j]:0;
;
	ldx     #$00
	lda     regbank+3
	bpl     L04FD
	dex
L04FD:	jsr     aslax4
	clc
	adc     #<(_campo)
	sta     ptr1
	txa
	adc     #>(_campo)
	sta     ptr1+1
	ldx     #$00
	lda     regbank+4
	bpl     L04FF
	dex
L04FF:	clc
	adc     ptr1
	sta     sreg
	txa
	adc     ptr1+1
	sta     sreg+1
	lda     regbank+3
	beq     L0509
	ldx     #$00
	lda     regbank+3
	bpl     L0505
	dex
L0505:	sec
	sbc     #$01
	bcs     L0506
	dex
L0506:	jsr     aslax4
	clc
	adc     #<(_campo)
	sta     ptr1
	txa
	adc     #>(_campo)
	sta     ptr1+1
	ldx     #$00
	lda     regbank+4
	bpl     L0508
	dex
L0508:	clc
	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	sta     ptr1+1
	ldy     #$00
	lda     (ptr1),y
L0509:	ldy     #$00
	sta     (sreg),y
;
; for (k=i;k>=0;k--)
;
	lda     regbank+3
	sec
	sbc     #$01
	jmp     L0584
;
; for (j=1;j<ANCHO+1;j++)
;
L04E7:	lda     regbank+4
	clc
	adc     #$01
	jmp     L0585
;
; nlineas++;
;
L04E6:	ldy     #$08
	lda     (sp),y
	clc
	adc     #$01
	sta     (sp),y
;
; txtx=19; txty=4;
;
	lda     #$13
	sta     _txtx
	lda     #$04
	sta     _txty
;
; prtnum(nlineas);
;
	lda     (sp),y
	jsr     pusha
	jsr     _prtnum
;
; if (nlineas>max) {
;
	ldy     #$08
	ldx     #$00
	lda     (sp),y
	bpl     L0515
	dex
L0515:	jsr     pushax
	ldy     #$09
	ldx     #$00
	lda     (sp),y
	bpl     L0516
	dex
L0516:	jsr     tosicmp
	bmi     L0513
	beq     L0513
;
; max=nlineas;
;
	ldy     #$08
	lda     (sp),y
	dey
	sta     (sp),y
;
; txtx=19; txty=7;
;
	lda     #$13
	sta     _txtx
	sty     _txty
;
; prtnum(max);
;
	lda     (sp),y
	jsr     pusha
	jsr     _prtnum
;
; display();
;
L0513:	jsr     _display
;
; delay16m(6);
;
	lda     #$06
	jsr     pusha
	jsr     _delay16m
;
; for (i=0;i<ALTO;i++) {
;
L04C8:	lda     regbank+5
	clc
	adc     #$01
	jmp     L0586
;
; txtx=2; txty=3; puts("GAME");
;
L03B7:	lda     #$02
	sta     _txtx
	lda     #$03
	sta     _txty
	lda     #<(L0001+4)
	ldx     #>(L0001+4)
	jsr     pushax
	jsr     _puts
;
; txtx=2; txty=5; puts("OVER");
;
	lda     #$02
	sta     _txtx
	lda     #$05
	sta     _txty
	lda     #<(L0001+9)
	ldx     #>(L0001+9)
	jsr     pushax
	jsr     _puts
;
; txtx=2;  txty=11; puts("press UP for new game");
;
	lda     #$02
	sta     _txtx
	lda     #$0B
	sta     _txty
	lda     #<(L0001+14)
	ldx     #>(L0001+14)
	jsr     pushax
	jsr     _puts
;
; a=cinnb();
;
L0535:	ldy     #$00
	jsr     _cinnb
	ldy     #$06
	sta     (sp),y
;
; if (a=='A') break;
;
	cmp     #$41
	jeq     L03A0
;
; if (a==0x90) break;
;
	lda     (sp),y
	cmp     #$90
	jeq     L03A0
;
; if (a=='q' || a==27) goto retorno;
;
	lda     (sp),y
	cmp     #$71
	beq     L0471
	lda     (sp),y
	cmp     #$1B
	bne     L0535
;
; PAGE2=pag[0];
;
L0471:	ldy     #$00
	lda     (sp),y
	sta     $E00A
;
; PAGE3=pag[1];
;
	iny
	lda     (sp),y
	sta     $E00B
;
; PAGE4=pag[2];
;
	iny
	lda     (sp),y
	sta     $E00C
;
; PAGE5=pag[3];
;
	iny
	lda     (sp),y
	sta     $E00D
;
; CTRL2=2; // Modo monocromo
;
	lda     #$02
	sta     $E003
;
; IOCHAN=0xC3;  // Con salida por UART
;
	lda     #$C3
	sta     $0018
;
; }
;
	ldy     #$10
	ldx     #$05
L0557:	lda     (sp),y
	sta     regbank+0,x
	dey
	dex
	bpl     L0557
	ldy     #$11
	jmp     addysp

.endproc

